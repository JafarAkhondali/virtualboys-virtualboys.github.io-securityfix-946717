<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - render-to-texture</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #ffffff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		
		<script src="js/node_modules/color-scheme/lib/color-scheme.min.js"></script>
		<script src="../build/three.min.js"></script>
		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/DotScreenShader.js"></script>
		<script src="js/shaders/RGBShiftShader.js"></script>
		<script src="js/shaders/LensShader.js"></script>
		<script src="js/shaders/GrainShader.js"></script>
		<script src="/socket.io/socket.io.js"></script>

		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>

		<script src="js/Detector.js"></script>

		<script id="fragment_shader_screen" type="x-shader/x-fragment">

			varying vec2 vUv;
			uniform float cutoff1;
			uniform float cutoff2;
			uniform float time;
			uniform vec4 baseColor;
			uniform vec4 color1;
			uniform vec4 color2;

			uniform sampler2D texMap;

			void main() {
				vec2 uv = vec2(vUv.x, vUv.y);
				uv.y +=time;
				uv.y -= floor(uv.y);
				vec4 texColor = texture2D( texMap, uv);
				if(texColor.r <= cutoff1)
					gl_FragColor = color2;
				else if(texColor.r <= cutoff2)
					gl_FragColor = color1;
				else
					gl_FragColor = baseColor;
			}

		</script>

		<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main() {

				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>


		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var cameraRTT, camera, camera2, renderer;
			var sceneTet, sceneTorus, sceneIcos, sceneShaded;
			var sceneScreen, sceneQuad, sceneQuad2, sceneShaderQuad;
			var currentQuad = 0;
			var sceneFade = 0;
			var lerps=[];
			var activeScenes = [];
			var tet1, tet2, torus, icos;
			var comp;

			var strips;
			var h2, w2;
			var textures=[];
			var aspect = 1;
			var shaderMaterial;

			var background, foreground;
			var backgroundTexs = [];
			var backgroundInd=0;
			var foregroundTexs= [];
			var foregroundInd = 0;

			var rgbTexture;
			var finalTex;
			var rtTexture, quadTex, quadTex2, shaderTex;
			var rgbshifttex, tex2, backgroundTex, foregroundTex;
			var uniformsMaterialColor= ["baseColor","color1","color2"];
			var effect,effect2,effect3;

			var numTextures = 6;
			var numTexLoaded = 0;

			//inputs
			var rotateSpeed = 0;
			var goalRotateSpeed=0;
			var obRotSpeed=0;
			var obRotAxisScale = 1;
			var obSpeed = 0;

			lerps[0]= {};
			lerps[0].current=rotateSpeed;
			lerps[0].goal=rotateSpeed;
			lerps[0].counter=0;
			lerps[0].counterMax=1000;
			var camSize = 800;
			var desiredCamSize= 600;
			lerps[1]={};
			lerps[1].current=camSize;
			lerps[1].goal=camSize;

			lerps[1].counter=0;
			lerps[1].counterMax=500;
			var zoomSpeed = 0;
			var baseHue = 0;

			var hue;
			var goalHue;
			lerps[2]={};
			lerps[2].counter=0;
			lerps[2].counterMax=1000;

			lerps[3]={};
			lerps[3].current = 0;
			lerps[3].goal=0;
			lerps[3].counter=0;
			lerps[3].counterMax=1000

			lerps[4]={};
			lerps[4].current = .5;
			lerps[4].goal=1.3;
			lerps[4].counter=0;
			lerps[4].counterMax=1000;

			var schemes = ['triade','tetrade','analogic'];
			var variations = ['pastel','soft','light','hard','pale'];
			var currentScheme = 2;
			var currentVariation = 2;

			init();
			//animate();

			function init() {

				cameraRTT = new THREE.OrthographicCamera( window.innerHeight / - 2, window.innerHeight / 2, 
					window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000 );

				camera = new THREE.OrthographicCamera( camSize / -2, camSize / 2, camSize / (2), 
					camSize / (-2), -10000, 10000 );
				camera2 = camera.clone();
				cameraRTT = camera.clone();

				sceneTet = new THREE.Scene();
				sceneTet.update = updateTet;

				sceneTorus = new THREE.Scene();
				sceneTorus.update = updateTorus;

				sceneTorus2 = new THREE.Scene();
				sceneTorus.update = updateTorus2;

				sceneIcos = new THREE.Scene();
				sceneIcos.update = updateIcos;

				sceneShaded = new THREE.Scene();
				sceneShaded.update = updateShaded;

				sceneScreen = new THREE.Scene();
				sceneQuad = new THREE.Scene();
				sceneQuad2 = new THREE.Scene();
				sceneShaderQuad = new THREE.Scene();

				activeScenes[0] = sceneShaded;

				hue = Math.random() * 360;
				lerps[2].current= hue;
				lerps[2].goal=Math.random() * 360;
				initTextures();

				initTorusScene2();
				//initTorus();
				initIcosScene();
				loadTextures();

				initKaleidescopeScene();

				var quad = new THREE.PlaneBufferGeometry(camSize,camSize/aspect);
				var mat = new THREE.MeshBasicMaterial({map:quadTex,transparent:true, depthWrite:false, depthTest: false});
				var quadOb = new THREE.Mesh(quad, mat);
				quadOb.position.set(0,0,100);
				sceneQuad.add(quadOb);

				mat = new THREE.MeshBasicMaterial({map:quadTex2,transparent:true, depthWrite:false, depthTest: false});
				quadOb = new THREE.Mesh(quad, mat);
				quadOb.position.set(0,0,100);
				sceneQuad2.add(quadOb);

				mat = new THREE.MeshBasicMaterial({map:shaderTex,transparent:true, depthWrite:false, depthTest: false});
				quadOb = new THREE.Mesh(quad, mat);
				quadOb.position.set(0,0,100);
				sceneShaderQuad.add(quadOb);

				renderer = new THREE.WebGLRenderer({ alpha: true });
				renderer.setSize( window.innerHeight, window.innerHeight );
				renderer.autoClear = false;

				comp = new THREE.EffectComposer( renderer );
				//comp.addPass( new THREE.RenderPass( background, cameraRTT) );
				comp.addPass( new THREE.RenderPass( sceneShaderQuad, cameraRTT) );
				//comp.addPass( new THREE.RenderPass( foreground, cameraRTT) );

				effect2 = new THREE.ShaderPass( THREE.RGBShiftShader );
				effect2.uniforms[ 'amount' ].value = 0.005;
				effect2.renderToScreen = false;
				comp.addPass( effect2 );

				effect3 = new THREE.ShaderPass( THREE.LensShader );
				effect3.uniforms[ 'scale' ].value = .65;
				effect3.renderToScreen = true;
				comp.addPass( effect3 );

				var container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );


			}
			addEventListener("click", function() {
    var
      el = document.documentElement
    , rfs =
           el.requestFullScreen
        || el.webkitRequestFullScreen
        || el.mozRequestFullScreen
    ;
    rfs.call(el);
});
			document.getElementById('container').onkeypress = function(event) {
			}

			function randScale() {
				return (.3+.7*Math.random())*2 -1;
			}

			function rollScales(scene) {
				for(var i = 0; i < scene.children.length; i++) {
					if(scene.children[i].rotSpeed)
						scene.children[i].rotScale = randScale();
					if(scene.children[i].speed)
						scene.children[i].speedScale = 1;
				}
			}

			function initTextures() {
				rtTexture = new THREE.WebGLRenderTarget( window.innerHeight, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
				quadTex = rtTexture.clone();
				quadTex2 = rtTexture.clone();
				shaderTex = rtTexture.clone();
				finalTex= rtTexture.clone();

			}


			function loadTextures() {
				rgbshifttex = THREE.ImageUtils.loadTexture( 'textures/stripes.jpg', {}, texLoadCallback);
				rgbshifttex.wrapS = rgbshifttex.wrapT = THREE.RepeatWrapping;
				rgbshifttex.anisotropy = 16;
				textures[0] = rgbshifttex;

				tex2 = THREE.ImageUtils.loadTexture( 'textures/squares.jpg', {}, texLoadCallback);
				tex2.wrapS = tex2.wrapT = THREE.RepeatWrapping;
				tex2.anisotropy = 16;
				textures[1] = tex2;

				var tex3 = THREE.ImageUtils.loadTexture( 'textures/bowling.jpg', {}, texLoadCallback);
				tex3.wrapS = tex3.wrapT = THREE.RepeatWrapping;
				tex3.anisotropy = 16;
				textures[2] = tex3;

				var tex4 = THREE.ImageUtils.loadTexture( 'textures/rectangles.jpg', {}, texLoadCallback);
				tex4.wrapS = tex4.wrapT = THREE.RepeatWrapping;
				tex4.anisotropy = 16;
				textures[3] = tex4;

				var tex5 = THREE.ImageUtils.loadTexture( 'textures/stripeSimple.png', {}, texLoadCallback);
				tex5.wrapS = tex5.wrapT = THREE.RepeatWrapping;
				tex5.anisotropy = 16;
				textures[4] = tex5;

				backgroundTex = THREE.ImageUtils.loadTexture( 'textures/white.png', {}, texLoadCallback);
				backgroundTex.wrapS = backgroundTex.wrapT = THREE.RepeatWrapping;
				backgroundTex.anisotropy = 16;
				backgroundTexs[0]= backgroundTex;

				backgroundTex = THREE.ImageUtils.loadTexture( 'textures/clouds.jpg', {}, texLoadCallback);
				backgroundTex.wrapS = backgroundTex.wrapT = THREE.RepeatWrapping;
				backgroundTex.anisotropy = 16;
				backgroundTex.animated = true;
				backgroundTexs[1]= backgroundTex;

				backgroundTex = THREE.ImageUtils.loadTexture( 'textures/bowling.jpg', {}, texLoadCallback);
				backgroundTex.wrapS = backgroundTex.wrapT = THREE.RepeatWrapping;
				backgroundTex.anisotropy = 16;
				backgroundTex.animated = false;
				backgroundTexs[2]= backgroundTex;

				backgroundTex = THREE.ImageUtils.loadTexture( 'textures/palm.jpg', {}, texLoadCallback);
				backgroundTex.wrapS = backgroundTex.wrapT = THREE.RepeatWrapping;
				backgroundTex.anisotropy = 16;
				backgroundTex.animated = true;
				backgroundTexs[3]= backgroundTex;

				backgroundTex = THREE.ImageUtils.loadTexture( 'textures/rectangles.jpg', {}, texLoadCallback);
				backgroundTex.wrapS = backgroundTex.wrapT = THREE.RepeatWrapping;
				backgroundTex.anisotropy = 16;
				backgroundTex.animated = false;
				backgroundTexs[4]= backgroundTex;
				backgroundInd=0;

				foregroundTex = THREE.ImageUtils.loadTexture( 'textures/waves.png', {}, texLoadCallback);
				foregroundTex.wrapS = foregroundTex.wrapT = THREE.RepeatWrapping;
				foregroundTex.anisotropy = 16;
				foregroundTex.isMask = false;
				foregroundTexs[0] = foregroundTex;

				foregroundTex = THREE.ImageUtils.loadTexture( 'textures/circle.png', {}, texLoadCallback);
				foregroundTex.wrapS = foregroundTex.wrapT = THREE.RepeatWrapping;
				foregroundTex.anisotropy = 16;
				foregroundTex.isMask = true;
				foregroundTexs[1] = foregroundTex;
				foregroundInd=1;
			}

			function texLoadCallback() {
				if(++numTexLoaded == textures.length+foregroundTexs.length +backgroundTexs.length) {
					initShadedScene();
					initTetScene();
					initBackground();
					animate();
				}
			}

			function initBackground() {
				var quad = new THREE.PlaneBufferGeometry(camSize,camSize/aspect);
				var mat = new THREE.ShaderMaterial( {
					transparent: true,
					alphaTest: 0.0,
					opacity     : 1.0,
					uniforms: { texMap: { type: "t", value: backgroundTex}, baseColor: { type: "v4", value : new THREE.Vector4(0, 0,0,0) }, 
						color1: { type: "v4", value : new THREE.Vector4(1,.69,.4,0) }, color2: { type: "v4", value : new THREE.Vector4(1,.69,.4,0) }, 
						cutoff1: { type:"1f", value: 0}, cutoff2: { type:"1f", value: .5}, time: { type:"1f", value: 0} },
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_screen' ).textContent,

				} );
				var quadOb = new THREE.Mesh(quad, mat);
				quadOb.position.set(0,0,100);
				quadOb.textured = true;

				background = new THREE.Scene();
				background.add(quadOb);
				background.on = false;
				background.background = true;
				initColorScheme(background, scheme);

				mat = new THREE.ShaderMaterial( {
					transparent: true,
					alphaTest: 0.0,
					opacity     : .4,
					uniforms: { texMap: { type: "t", value: foregroundTex}, baseColor: { type: "v4", value : new THREE.Vector4(0, 0,0,1) }, 
						color1: { type: "v4", value : new THREE.Vector4(1,.69,.4,0) }, color2: { type: "v4", value : new THREE.Vector4(1,.69,.4,0) }, 
						cutoff1: { type:"1f", value: .3}, cutoff2: { type:"1f", value: .6}, time: { type:"1f", value: 0} },
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_screen' ).textContent,
				} );

				quadOb = new THREE.Mesh(quad, mat);
				quadOb.position.set(0,0,100);
				quadOb.textured = true;

				foreground = new THREE.Scene();
				foreground.add(quadOb);
				foreground.on = false;
				foreground.foreground = true;
				initColorScheme(foreground, scheme);

			}

			function genTexturedMat(texture, baseColor, color1, color2) {
				return new THREE.ShaderMaterial( {
					transparent: true,
					alphaTest: 0.0,
					opacity     : 1.0,
					uniforms: { texMap: { type: "t", value: texture}, baseColor: { type: "v4", value : baseColor }, 
						color1: { type: "v4", value : color1 }, color2: { type: "v4", value : color2 }, cutoff1: { type:"1f", value: .05}, cutoff2: { type:"1f", value: .9}, time: { type:"1f", value: 0} },
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_screen' ).textContent,

				} );
			}

			function setupMoveOb(ob) {
				ob.baseDist = new THREE.Vector3().subVectors(ob.p1,ob.p2).length();
				ob.basePos = new THREE.Vector3().addVectors(ob.p1,ob.p2).divideScalar(2);
				ob.transPos = true;
			}	

			var scheme;
			function initTetScene() {

				var geometry = new THREE.TetrahedronGeometry( 100,1 );

				var mat1 = new THREE.MeshBasicMaterial( { color: 0xEFD4FF,shading: THREE.FlatShading} );
				var mat2 = new THREE.MeshBasicMaterial( { color: 0xD4FFEF,shading: THREE.FlatShading} );

				mat1 = genTexturedMat(textures[2], new THREE.Vector4(0,0,0,1), new THREE.Vector4(0,0,0,1), new THREE.Vector4(0,0,0,1));

				tet1 = new THREE.Mesh( geometry, mat1 );
				tet1.textured = true;
				tet1.position.set( 100, 0, 100 );
				tet1.scale.set( 2.4, 2.4, 2.4 );

				tet1.p1 = tet1.position.clone();
				tet1.p2 = (new THREE.Vector3(-25,0,-100)).add(tet1.position);
				tet1.speed = .5;
				setupMoveOb(tet1);

				tet1.rotAxis = new THREE.Vector3(1,2,0).normalize();
				tet1.rotSpeed = .01;

				sceneTet.add( tet1 );

				//scaleObDist(tet1, 4);

				tet2 = new THREE.Mesh( geometry, mat2 );
				tet2.position.set( 300, 300, 100 );
				tet2.scale.set( 2.7, 2.7, 2.7 );

				tet2.p1 = tet2.position.clone();
				tet2.p2 = (new THREE.Vector3(100,25,50)).add(tet1.position);
				tet2.speed = .02;
				setupMoveOb(tet2);

				tet2.rotAxis = new THREE.Vector3(0,1,0);
				tet2.rotSpeed = -.02;

				sceneTet.add( tet2 );

				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 0, 1 ).normalize();
				//sceneTet.add( light );

				light = new THREE.DirectionalLight( 0xffffff, 1.5 );
				light.position.set( 1, 0, .2 ).normalize();
				//``sceneTet.add( light );

				light = new THREE.DirectionalLight( 0xffffff, 1.5 );
				light.position.set( 0, 1, 0 ).normalize();
				//sceneTet.add( light );

				light = new THREE.DirectionalLight( 0xffffff, 1.5 );
				light.position.set( 0, -1, 0 ).normalize();
				//sceneTet.add( light );

				scheme = new ColorScheme;
 				scheme.from_hue(hue) 
 				.scheme(schemes[currentScheme])   
        		.variation(variations[currentVariation]);
        		scheme.hue=hue;
        		scheme.sc=schemes[currentScheme];
        		scheme.variation= variations[currentVariation];
        		initColorScheme(sceneTet,scheme);

			}

			function initTorusScene() {
				var geometry = new THREE.TorusGeometry(110,20,32,32);
				var mat1 = new THREE.MeshBasicMaterial( { color: 0xFF5C80 ,side:THREE.DoubleSide,shading: THREE.FlatShading} );
				//mat1 = genTexturedMat(rgbshifttex, new THREE.Vector4(1,.6,1,1), new THREE.Vector4(.6,.1,1,1), new THREE.Vector4(1,1,.6,1));

				torus = new THREE.Mesh(geometry, mat1);
				//torus.textured=true;
				torus.position.set(100,50,100);
				torus.scale.set(2.2,2.2,2.2);
				torus.baseScale = 2.2;
				torus.rotSpeed = .014;

				torus.rotAxis = new THREE.Vector3(.2,1,0).normalize();

				torus.p1= new THREE.Vector3(300,20,100);
				torus.p2= new THREE.Vector3(-300,-20,100);
				torus.speed=1;
				setupMoveOb(torus);

				sceneTorus.add( torus );

				var geometry = new THREE.TorusGeometry( 80, 20, 32,32 );
				var mat1 = new THREE.MeshBasicMaterial( { color: 0x5CFF80 ,side:THREE.DoubleSide,shading: THREE.FlatShading} );
				//mat1 = genTexturedMat(rgbshifttex, new THREE.Vector4(1,.6,1,1), new THREE.Vector4(.6,.1,1,1), new THREE.Vector4(1,1,.6,1));
				var torus = new THREE.Mesh(geometry, mat1);
				torus.position.set(100,50,100);
				//torus.textured=true;
				torus.scale.set(2.2,2.2,2.2);
				torus.baseScale = 2.2
				torus.rotSpeed = .02;
				torus.rotAxis = new THREE.Vector3(1,.2,0).normalize();
				torus.p1= new THREE.Vector3(300,20,100);
				torus.p2= new THREE.Vector3(-300,-20,100);
				torus.speed=1;
				setupMoveOb(torus);

			    sceneTorus.add(torus);
				var geometry = new THREE.SphereGeometry( 50, 32, 32 );
				var material = new THREE.MeshBasicMaterial( {color: 0x5C80FF} );
				//material= genTexturedMat(rgbshifttex, new THREE.Vector4(1,.6,1,1), new THREE.Vector4(.6,.1,1,1), new THREE.Vector4(1,1,.6,1));
				var sphere = new THREE.Mesh( geometry, material );
				//sphere.textured=true;
				sphere.position.set(100,50,100);
				sphere.scale.set(2.2,2.2,2.2);
				sphere.baseScale = 2.2;
				sphere.rotSpeed =0;
				sphere.p1= new THREE.Vector3(300,20,100);
				sphere.p2= new THREE.Vector3(-300,-20,100);
				sphere.speed=1;
				setupMoveOb(sphere);

				sceneTorus.add( sphere );
				var geometry = new THREE.TorusGeometry( 80, 20, 32,32 );
				var mat1 = new THREE.MeshBasicMaterial( { color: 0x5CFF80 ,side:THREE.DoubleSide,shading: THREE.FlatShading} );
				//mat1 = genTexturedMat(rgbshifttex, new THREE.Vector4(1,.6,1,1), new THREE.Vector4(.6,.1,1,1), new THREE.Vector4(1,1,.6,1));
				var torus = new THREE.Mesh(geometry, mat1);
				torus.position.set(500,50,100);
				//torus.textured=true;
				torus.scale.set(2.2,2.2,2.2);
				torus.baseScale = 2.2;
				torus.rotSpeed = .03;
				torus.rotAxis = new THREE.Vector3(.5,.5,0).normalize();
				torus.p1= new THREE.Vector3(1000,50,100);
				torus.p2= new THREE.Vector3(-1000,-50,100);
				torus.speed=2;
			    sceneTorus.add(torus);
				var geometry = new THREE.SphereGeometry( 50, 32, 32 );
				var material = new THREE.MeshBasicMaterial( {color: 0x5C80FF} );
				//material= genTexturedMat(rgbshifttex, new THREE.Vector4(1,.6,1,1), new THREE.Vector4(.6,.1,1,1), new THREE.Vector4(1,1,.6,1));
				var sphere = new THREE.Mesh( geometry, material );
				sphere.position.set(500,50,100);
				sphere.scale.set(2.2,2.2,2.2);
				sphere.baseScale = 2.2;
				//sphere.textured=true;
				sphere.rotSpeed =0;
				sphere.p1= new THREE.Vector3(1000,50,100);
				sphere.p2= new THREE.Vector3(-1000,-50,100);
				sphere.speed=1.4;
				sceneTorus.add( sphere );
				scheme = new ColorScheme;
 				scheme.from_hue(hue) 
 				.scheme(schemes[currentScheme])   
        		.variation(variations[currentVariation]);
        		scheme.hue=hue;
        		scheme.sc=schemes[currentScheme];
        		scheme.variation= variations[currentVariation];
        		initColorScheme(sceneTorus,scheme);

        		rollScales(sceneTorus);

        		//updateTextures(sceneTorus);
			}

			function initTorusScene2(){
				var geometry = new THREE.TorusKnotGeometry(130,40,32,32);
				var mat1 = new THREE.MeshBasicMaterial( { color: 0xFF5C80 ,side:THREE.DoubleSide,shading: THREE.FlatShading} );
				//mat1 = genTexturedMat(rgbshifttex, new THREE.Vector4(1,.6,1,1), new THREE.Vector4(.6,.1,1,1), new THREE.Vector4(1,1,.6,1));

				torus = new THREE.Mesh(geometry, mat1);
				//torus.textured=true;
				torus.position.set(100,50,100);
				torus.rotSpeed = .014;

				torus.rotAxis = new THREE.Vector3(.2,1,0).normalize();

				torus.p1= new THREE.Vector3(300,20,100);
				torus.p2= new THREE.Vector3(-300,-20,100);
				torus.speed=1;
				setupMoveOb(torus);

				sceneTorus2.add( torus );
				scheme = new ColorScheme;
 				scheme.from_hue(hue) 
 				.scheme(schemes[currentScheme])   
        		.variation(variations[currentVariation]);
        		scheme.hue=hue;
        		scheme.sc=schemes[currentScheme];
        		scheme.variation= variations[currentVariation];
        		initColorScheme(sceneTorus2,scheme);
        		rollScales(sceneTorus2);

			}

			function updateTorus() {
				updateSceneObjects(sceneTorus);
			}
			function updateTorus2() {
				updateSceneObjects(sceneTorus2);
			}
			function initIcosScene() {
				var geom = new THREE.IcosahedronGeometry(200);
				var mat = new THREE.MeshLambertMaterial({color:0xFFFFFF, shading: THREE.FlatShading});
				icos = new THREE.Mesh(geom, mat);
				icos.position.set(100,100,100);
			
				sceneIcos.add(icos);

				var light = new THREE.DirectionalLight( 0xFFFFFF, 1.5 );
				light.position.set( 1, 0, .2 ).normalize();
				sceneIcos.add( light );

				light = new THREE.AmbientLight( 0x999999);
				//sceneIcos.add( light );
				scheme = new ColorScheme;
 				scheme.from_hue(hue) 
 				.scheme(schemes[currentScheme])   
        		.variation(variations[currentVariation]);
        		scheme.hue=hue;
        		scheme.sc=schemes[currentScheme];
        		scheme.variation= variations[currentVariation];
        		initColorScheme(sceneIcos,scheme);
			}
			function changeMap(mat,url){
				rgbshifttex = THREE.ImageUtils.loadTexture( 'url', {}, texLoadCallback);
				rgbshifttex.wrapS = rgbshifttex.wrapT = THREE.RepeatWrapping;
				rgbshifttex.anisotropy = 16;

			}
			function initShadedScene() {
				var mat = new THREE.MeshPhongMaterial( { alphaTest: 0.5, ambient: 0xffffff, color: 0xffffff, specular: 0x030303, emissive: 0x111111, shiness: 10, map: rgbshifttex, side: THREE.DoubleSide} );
				mat = genTexturedMat(rgbshifttex, new THREE.Vector4(1,.6,1,1), new THREE.Vector4(.6,.1,1,1), new THREE.Vector4(1,1,.6,1));

				var geom = new THREE.IcosahedronGeometry(400);

				var icos = new THREE.Mesh(geom, mat);
				icos.position.set(100,100,100);
				icos.speed = 1;
				icos.p1 = new THREE.Vector3(100,100,500);
				icos.p2 = new THREE.Vector3(100,100,300);
				setupMoveOb(icos);

				icos.rotSpeed = .02;
				icos.rotAxis = new THREE.Vector3(0,1,.5).normalize();
				icos.textured =true;
				sceneShaded.add(icos);

				var mat2 = new THREE.MeshPhongMaterial( { alphaTest: 0.5, ambient: 0xffffff, color: 0xffffff, specular: 0x030303, emissive: 0x111111, shiness: 10, map: tex2, side: THREE.DoubleSide} );
				mat2 = genTexturedMat(tex2, new THREE.Vector4(1,.6,1,1), new THREE.Vector4(1,1,.7,1), new THREE.Vector4(1,.7,1,1));

				var geom2 = new THREE.BoxGeometry(300, 300, 300);

				var cube = new THREE.Mesh(geom2, mat2);
				cube.position.set(100,100,500);
				cube.speed = 0;
				cube.rotSpeed = .01;
				cube.rotAxis = new THREE.Vector3(1, 1, 0).normalize();
				cube.textured=true;
				sceneShaded.add(cube);

				var light = new THREE.DirectionalLight( 0xFFFFFF, 1.5 );
				light.position.set( 1, 0, .2 ).normalize();
				light.speed = 0;
				light.rotSpeed = 0;
				//sceneShaded.add( light );

				light = new THREE.AmbientLight( 0xFFFFFF);
				light.speed = 0;
				light.rotSpeed = 0;
				sceneShaded.add( light );
				scheme = new ColorScheme;
 				scheme.from_hue(hue) 
 				.scheme(schemes[currentScheme])   
        		.variation(variations[currentVariation]);
        		scheme.hue=hue;
        		scheme.sc=schemes[currentScheme];
        		scheme.variation= variations[currentVariation];
        		initColorScheme(sceneShaded,scheme);
        		updateTextures(sceneShaded);

        		rollScales(sceneShaded);

			}

			function updateTextures(scene){
				for(var i =0; i<scene.children.length; i++){
					if(scene.children[i].textured){
						var t= Math.floor(Math.random()*(textures.length-1));
						scene.children[i].material.uniforms["texMap"].value= textures[t]; 
						scene.children[i].material.uniforms["texMap"].needsUpdate = true;
					}
				}
			}
			function initColorScheme(scene,scheme){ 
				var baseind=4;
				var colorind=baseind;
				var schemenew = new ColorScheme;
				schemenew.from_hue(scheme.hue) 
 				.scheme(scheme.sc)   
        		.variation(scheme.variation);
        		schemenew.hue=scheme.hue;
        		schemenew.sc=scheme.sc;
        		schemenew.variation=scheme.variation;
        		scheme=schemenew;
        		var colors = scheme.colors();				
        		for(var i =0; i<scene.children.length; i++){
					if(scene.children[i] instanceof THREE.Mesh){
						if(scene.children[i].textured){

							scene.children[i].colorinds=[];
							colorind = Math.floor(Math.random()*colors.length/4)*4;

							for(var j=0; j<3; j++){
								
								var rgb=hexToRgb(colors[colorind]);
								colorind+=4;
								colorind = colorind % (colors.length);

								//if(rgb.r >= 0.2 && rgb.g >= 0.2 && rgb.b >= 0.2)
								//	scene.children[i].material.uniforms[uniformsMaterialColor[j]].value= new THREE.Vector4(0,0,0,0);
								//else
								if(scene.background)
									scene.children[i].colorinds[j]=colorind;
								else if(scene.foreground)
									scene.children[i].colorinds[j]=colorind+2;
								else
									scene.children[i].colorinds[j]=colorind+3;
								scene.children[i].material.uniforms[uniformsMaterialColor[j]].value= new THREE.Vector4(rgb.r,rgb.g,rgb.b,1);
							}
						}
						else{
							colorind = Math.floor(Math.random()*colors.length/4)*4+3;

							var rgb=hexToRgb(colors[colorind]);	
							scene.children[i].colorind=colorind;
							scene.children[i].material.color.setRGB(rgb.r,rgb.g,rgb.b);
						}	
					}
				}
				scene.clearColor = hexToRgb(colors[colorind]);
			}
			function updateColorScheme(scene,scheme){
				var schemenew = new ColorScheme;
				schemenew.from_hue(lerps[2].current) 
 				.scheme(scheme.sc)   
        		.variation(scheme.variation);
        		schemenew.hue=lerps[2].current;
        		schemenew.sc=scheme.sc;
        		schemenew.variation=scheme.variation;
        		scheme=schemenew;
        		var colors = scheme.colors();
        		for(var i =0; i<scene.children.length; i++){
					if(scene.children[i] instanceof THREE.Mesh){
						if(scene.children[i].textured){
							for(var j=0; j<3; j++){
								var colorind = scene.children[i].colorinds[j];
								var rgb=hexToRgb(colors[colorind]);
								scene.children[i].material.uniforms[uniformsMaterialColor[j]].value= new THREE.Vector4(rgb.r,rgb.g,rgb.b,scene.children[i].material.uniforms[uniformsMaterialColor[j]].value.w);
							}
						}
						else{
							var colorind = scene.children[i].colorind;
							var rgb=hexToRgb(colors[colorind]);	
							scene.children[i].material.color.setRGB(rgb.r,rgb.g,rgb.b);
						}	
					}
				}
			}
			function hexToRgb(hex) {
    			var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    			return result ? {
        			r: (parseInt(result[1], 16))/256.0,
        			g: (parseInt(result[2], 16))/256.0,
        			b: (parseInt(result[3], 16))/256.0
    			} : null;
			}

			function initKaleidescopeScene() {

				h2 = 30*Math.sqrt(27);
				w2 = 30*3;

				var geometry = new THREE.Geometry();
				geometry.vertices.push(
					new THREE.Vector3(0, h2, 0),
					new THREE.Vector3(-w2, 0, 0 ),
					new THREE.Vector3(w2, 0, 0 ),
					new THREE.Vector3(0, -h2, 0)
				);

				geometry.faces.push( new THREE.Face3( 0, 1, 2 ) );
				geometry.faces.push( new THREE.Face3( 3, 2, 1 ) );
				
				var uvs = [];
				uvs.push( new THREE.Vector2( 0.5, 0.0 ) );
				uvs.push( new THREE.Vector2( 0.0, Math.sqrt(.75) ) );
				uvs.push( new THREE.Vector2( 1.0, Math.sqrt(.75) ) );

				geometry.faceVertexUvs[ 0 ].push( [ uvs[0], uvs[1], uvs[2] ] );
				geometry.faceVertexUvs[ 0 ].push( [ uvs[0], uvs[2], uvs[1] ] );
				var mat = new THREE.MeshBasicMaterial( { map: rtTexture, side: THREE.DoubleSide,transparent:true, depthWrite:false, depthTest: false} );

				var triangle = new THREE.Mesh( geometry, mat);
				triangle.position.set(0,0,100);

				var geom2 = geometry.clone();
				geom2.faceVertexUvs[0][0] = [ uvs[2], uvs[1], uvs[0] ];
				geom2.faceVertexUvs[0][1] = [ uvs[2], uvs[0], uvs[1] ]; 
				var tri2 = new THREE.Mesh( geom2, mat);
				tri2.position.set(w2,h2,100);
				tri2.rotation.set(0,0,-Math.PI);

				var geom3 = geometry.clone();
				geom3.faceVertexUvs[0][0] = [ uvs[1], uvs[2], uvs[0] ];
				geom3.faceVertexUvs[0][1] = [ uvs[1], uvs[0], uvs[2] ]; 
				var tri3 = new THREE.Mesh( geom3, mat);
				tri3.position.set(2*w2,2*h2,100);

				var primitives = [triangle, tri2, tri3];
				strips = [];

				for(var j = 0; j < 40; j++){
					strips[j] = [];
					for(var i = 0; i < 16; i++) {
						for(var n = 0; n < 3; n++) {
							var p = primitives[n].clone();
							p.position.add(new THREE.Vector3((3*(i-4)  )*w2, (3*(i-1) - 2*(j-10))*h2, 0));
							sceneScreen.add(p);
							strips[j][i*3 + n] = p;
						}
					}
				}
			}

			function translateStrip(strip, amt) {
				for(var i = 0; i < strip.length; i++) {
					strip[i].position.add(new THREE.Vector3(amt*w2,amt*h2,0));
				}
			}

			function scaleObDist(ob, scale) {
            	var dir = new THREE.Vector3().subVectors(ob.p1,ob.p2).normalize();
            	dir.multiplyScalar(scale * ob.baseDist);
            	ob.p1 = ob.basePos.clone().add(dir);
            	ob.p2 = ob.basePos.clone().sub(dir);
			}
			var counter=0;
			function animate() {
				zoom();
				sceneShaded=sceneTorus2;
				for(var i=0; i<lerps.length;i++){
					lerps[i].counter++;
					if(lerps[i].counter>lerps[i].counterMax){
						lerps[i].counter=0;
					}
					lerps[i].current=lerp(lerps[i].current,lerps[i].goal,lerps[i].counter/lerps[i].counterMax);
				}
				effect2.uniforms[ 'amount' ].value = lerps[3].current;
				counter++;
				if(counter>1000)
					counter=0;
				requestAnimationFrame( animate );

				//sceneTet.update();
				//sceneIcos.update();
				sceneTorus.update();
				sceneShaded.update();
				sceneTorus2.update()
				updateScale();
				updateColorScheme(sceneTorus,scheme);
				updateColorScheme(sceneTorus2,scheme);
				updateColorScheme(sceneShaded,scheme);
				updateColorScheme(background, scheme);

				if(!foregroundTexs[foregroundInd].isMask)
					updateColorScheme(foreground, scheme);

				updateCamera();

				if(background.on && backgroundTexs[backgroundInd].animated)
					updateBackground();
				if(foreground.on && !foregroundTexs[foregroundInd].isMask)
					updateForeground();

				render();

			}
			var counter=0;
			function zoom(){


				//camSize=lerp(camSize, desiredCamSize,counter/1000);

				camera.left = lerps[1].current / -2;
				camera.right = lerps[1].current / 2;
				camera.top = lerps[1].current / (2*aspect);
				camera.bottom = lerps[1].current / (-2*aspect);
				camera.updateProjectionMatrix();
			}
			function lerp(v1,v2,t){
				return (v1*(1-t)+v2*t);
			}
			function updateSceneObjects(scene) {
				for(var i = 0; i < scene.children.length; i++) {
					var ob = scene.children[i];
					if(ob.speed)
						updateObPos(ob);
					if(ob.rotSpeed)
						updateObRot(ob);
				}
			}
			function updateScale(){
            	for(var i = 0; i < sceneShaded.children.length; i++) {
            		var s = lerps[4].current;
            		sceneShaded.children[i].scale.set(s,s,s);
            	}
            	for(var i = 0; i < sceneTorus2.children.length; i++) {
            		var s = lerps[4].current;
            		sceneShaded.children[i].scale.set(s,s,s);
            	}
				for(var i = 0; i < sceneTorus.children.length; i++) {
					var s = sceneTorus.children[i].baseScale*lerps[4].current;
            		sceneTorus.children[i].scale.set(s,s,s);
            	}

			}
			function updateObPos(ob) {
				var dir = ob.p2.clone().sub(ob.p1);
				dir.normalize();

				var speed = obSpeed * ob.speedScale;
				if(!ob.transPos)
					speed = -speed;
				
				ob.position.add(dir.multiplyScalar(speed));
				

				var dest = ob.transPos ? ob.p2 : ob.p1;
				if(dir.dot(dest.clone().sub(ob.position)) < 0)
					ob.transPos = !ob.transPos;
			}

			function updateObRot(ob) {
				ob.rotateOnAxis(ob.rotAxis.clone().multiplyScalar(obRotAxisScale), obRotSpeed*ob.rotScale/obRotAxisScale);
			}

			var oTime = Date.now();
			var tpassed;
			function updateTet() {
				var time = Date.now() * 0.0015;
				tpassed = Date.now() - oTime;

				if(tpassed>800){
					tpassed=0;
					oTime=Date.now();
				}

				//tet1.rotation.y = - time;

				//updateObPos(tet1);
				updateSceneObjects(sceneTet);
				
				//tet2.rotation.y = - time + Math.PI / 2;

			}

			function updateShaded() {
				updateSceneObjects(sceneShaded);
			}

			function updateIcos() {
				icos.rotateOnAxis(new THREE.Vector3(.2,.4,.6).normalize(), .01);
				icos.scale.set(icos.scale.x,icos.scale.y,icos.scale.z);
				//icos.scale.x+=.004;
				//icos.scale.y+=.005;
				//icos.scale.z+=.002;
			}

			var updateCount = 0;
			var backgroundUp = true;
			var backP = 100;
			var addAmt = .5 / backP;
			function updateBackground() {
				var mat = background.children[0].material;
				var add = backgroundUp ? addAmt : -addAmt;
				mat.uniforms['cutoff1'].value += add;
				mat.uniforms['cutoff2'].value += add;

				if(updateCount++ == backP) {
					backgroundUp = !backgroundUp;
					updateCount = 0;
				}
			}

			var updateCountF = 0;
			var foregroundUp = true;
			var foreP = 1000;
			var addAmtF = .5 / foreP;
			function updateForeground() {
				var mat = foreground.children[0].material;
				var add = foregroundUp ? addAmtF : -addAmtF;
				mat.uniforms['cutoff1'].value += add;
				mat.uniforms['cutoff2'].value += add;

				if(!foregroundTexs[foregroundInd].isMask)
					mat.uniforms['time'].value += .001;
				else
					mat.uniforms['time'].value = 0;

				if(updateCountF++ == foreP) {
					foregroundUp = !foregroundUp;
					updateCountF = 0;
				}
			}

			function updateStrips() {
				var trans = 1;
				var forward = true;
				if(forward) {
					trans = .005;
				} else {
					trans = -.005;
				}
				/*for(var i = 0; i < strips.length; i++) {
					if(i%2 == 0) {
						translateStrip(strips[i], trans);
					} else {
						translateStrip(strips[i], -trans);
					}
				}*/
			}

			function updateCamera() {
				//cameraRTT.rotateOnAxis(new THREE.Vector3(0,0,1),.004);
				camera.rotateOnAxis(new THREE.Vector3(0,0,1),lerps[0].current);
				//camera2.rotateOnAxis(new THREE.Vector3(0,0,1),.004);

			}

			function render() {
				//var s = "rgb("+256*sceneTet.clearColor.r+","+256*sceneTet.clearColor.g+","+256*sceneTet.clearColor.b+")";
				var s = "rgb(256,256,256)";
				//renderer.setClearColor(s,0);

				//renderer.clear(rtTexture, true, true, true);

				renderer.setClearColor(0xffff00, 0);
				

				// Render first scene into texture

				if(sceneFade > 0)
					sceneFade -= .01;
				else
					sceneFade = 0;

				var quad = (currentQuad == 0) ? sceneQuad : sceneQuad2;
				var quad2 = (currentQuad == 0) ? sceneQuad2 : sceneQuad;

				if(sceneFade != 0) {
					quad2.children[0].material.opacity = sceneFade;
					quad.children[0].material.opacity = 1-sceneFade;
				} else {
					quad2.children[0].material.opacity = 0;
					quad.children[0].material.opacity = 1;
				}
				
				if(sceneFade != 0 || currentQuad == 0) {
					renderer.render(sceneShaded, cameraRTT, rtTexture, true);
					renderer.render(sceneScreen, camera, quadTex, true);
				}
				if(sceneFade != 0 || currentQuad == 1) {
					renderer.render(sceneTorus, cameraRTT, rtTexture, true);
					renderer.render(sceneScreen, camera, quadTex2, true);
				}

				renderer.render(background, cameraRTT, shaderTex, true);

				
				if(sceneFade != 0) {
					renderer.render(sceneQuad2, cameraRTT, shaderTex, false);
					renderer.render(sceneQuad, cameraRTT, shaderTex, false);
				} else if(currentQuad == 0) {
					renderer.render(sceneQuad, cameraRTT, shaderTex, false);
				} else {
					renderer.render(sceneQuad2, cameraRTT, shaderTex, false);
				}

				if(foreground.on)
					renderer.render(foreground, cameraRTT, shaderTex, false);

				comp.render();

				

			}

	    var socket = io.connect('http://localhost:8080');
            socket.on('rotate', function(message) {
                var newVal = (message / 1023-.5)  * .015;
                if(Math.abs(newVal-lerps[0].goal)>.005){
                	lerps[0].counterMax=1000;
                	lerps[0].goal =newVal;
                	lerps[0].counter=0;
                }
            });
            socket.on('zoom', function(message) {
                var newVal =message / 1023  * 800.0 + 400;
                 if(Math.abs(newVal-lerps[1].goal)>5){
                	lerps[1].goal =newVal;
                	lerps[1].counter=0;
                }
            });

            socket.on('opacity', function(message) {
                //quadMat.opacity= message/1024;
            });

            socket.on('obDist', function(message) {
            	/*for(var i = 0; i < sceneTet.children.length; i++) {
            		if(sceneTet.children[i].speed)
            			scaleObDist(sceneTet.children[i], message / 1023);
            	}
            	for(var i = 0; i < sceneTorus.children.length; i++) {
            		if(sceneTorus.children[i].speed)
            			scaleObDist(sceneTorus.children[i], message / 1023);
            	}*/
            });
            socket.on('obRot', function(message) {
            	var rotSpeed = .12 * (message / 1023 - .5);

            	obRotSpeed=rotSpeed;

            	//sceneTet.children[0].rotSpeed = rotSpeed;
            	//sceneShaded.children[0].rotSpeed = rotSpeed;
            });
            socket.on('obScale', function(message) {
            	var scale = (message / 1023)*(message / 1023)+.75;
            	if(Math.abs(scale-lerps[4].goal)>.01){
                	lerps[4].goal =scale;
                	lerps[4].counter=0;
                }

            	//sceneTet.children[0].rotSpeed = rotSpeed;
            	//sceneShaded.children[0].rotSpeed = rotSpeed;
            });

            socket.on('obSpeed', function(message) {
                obSpeed = 10 * (message / 1023 - .5);
                obSpeed = Math.abs(obSpeed);
            });
            socket.on('obRotAxisScale', function(message) {
                obRotAxisScale = (message / 1023 + .5);
            });
            socket.on('blackButton', function(message) {
                currentQuad = Math.abs(currentQuad-1);
                if(sceneFade == 0) {
                	sceneFade = 1;
                	if(currentQuad == 0) {
                		initColorScheme(sceneShaded, scheme);
                		updateTextures(sceneShaded);
                		rollScales(sceneShaded);
                	} else {
                		initColorScheme(sceneTorus, scheme);
                		rollScales(sceneTorus);
                	}
                }
            });
            socket.on('lightButton1', function(message) {
                if(message == 1){
                	foreground.on = true;
                	foregroundInd++;
                	if(foregroundInd>foregroundTexs.length-1)
                		foregroundInd=0;
                	foreground.children[0].material.uniforms["texMap"].value= foregroundTexs[foregroundInd];
                	foreground.children[0].material.uniforms["baseColor"].value =new THREE.Vector4(0, 0,0,0);
                	if(!foregroundTexs[foregroundInd].isMask) {
                		foreground.children[0].material.uniforms["color1"].value.w = .25;
                		foreground.children[0].material.uniforms["color2"].value.w = .5;
                	} else {
                		foreground.children[0].material.uniforms["color1"].value.set(0,0,0,1);
                		foreground.children[0].material.uniforms["color2"].value.set(0,0,0,1);
                		foreground.children[0].material.uniforms["cutoff1"].value = .5;
                		foreground.children[0].material.uniforms["cutoff2"].value = .9;
                		foreground.children[0].material.uniforms["time"].value = 0;
                	}
                }
                else{
                	foreground.on = false;
                }
            });
            socket.on('lightButton2', function(message) {
                if(message == 1){
                	background.on = true;
                	backgroundInd++;
                	if(backgroundInd>backgroundTexs.length-1)
                		backgroundInd=1;
                	background.children[0].material.uniforms["texMap"].value= backgroundTexs[backgroundInd];
                	if(!backgroundTexs[backgroundInd].animated) {
                		background.children[0].material.uniforms["cutoff1"].value = .2;
                		background.children[0].material.uniforms["cutoff2"].value = .9;
                	}
                }
                else{
                	background.on = false;
                	background.children[0].material.uniforms["texMap"].value= backgroundTexs[0]; 
                }
            });


            //little panel
            socket.on('hue', function(message) {
                var newVal= message / 1023 * 350;
                if(Math.abs(newVal-lerps[2].goal)>2){
                	lerps[2].counter=0;
                	lerps[2].goal=newVal;
                	lerps[2].counterMax=1000;
                }

            });

            var schemePressed = false;
            socket.on('button1', function(message) {
            	if(message == 1) {
            		currentScheme = (currentScheme+1) % schemes.length;
	            	scheme.sc = schemes[currentScheme];
            	}
            });

            var varPressed = false;
            socket.on('button4', function(message) {
            	if(message == 1) {
            		currentVariation = (currentVariation+1) % variations.length;
            		scheme.variation = variations[currentVariation];
            	}
            	
            });

            socket.on('shader1On', function(message) {
            	if(message > 500) {

            	} else {

            	}
            });

            socket.on('shader1knob', function(message) {
            	var val = .5+.25*(message / 1023);
            	//effect.uniforms[ 'scale' ].value = val;
            });

            socket.on('button5', function(message) {
            	if(message == 1){
            		if(comp.passes.length == 2) {
            			comp.passes[comp.passes.length-1].renderToScreen=false;
            			comp.addPass(effect);
            		}
            	} else {
            		if(comp.passes.length == 3) {
            			comp.passes.splice(2,1);
            			comp.passes[comp.passes.length-1].renderToScreen=true;
            		}
            	}
            });

            socket.on('shader2On', function(message) {
            	if(message > 500) {

            	} else {

            	}
            });
            socket.on('shader2knob', function(message) {
            	var val = .03*(message / 1023);
            	if(Math.abs(val-lerps[2].goal)>(.03/1024)*3){
                	lerps[3].counter=0;
                	lerps[3].goal=val;
                	lerps[3].counterMax=1000;
                }
            	
            });
            socket.on('shader2Arg', function(message) {
            	
            });
		</script>
	</body>
</html>
